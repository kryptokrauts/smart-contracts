contract PaymentSplitter =
   record state =
      {  owner: address,
         recipientConditions: map(address, int) } // map of recipients with percentage to receive (value between 1 and 100)
      
   datatype event = AddingInitialRecipients()
      | RecipientAdded(indexed address, indexed int)
      | AddressUpdated(indexed address, indexed address)
      | UpdatingAllRecipients()

   public stateful function init(recipients': map(address, int)) : state =
      require(sumWeights(recipients') == 100, "sum of weights needs to be 100")
      Chain.event(AddingInitialRecipients)
      {  owner = Call.caller,
         recipientConditions = recipients'}

   public function recipientsCount() : int =
      Map.size(state.recipientConditions)

   public function weightOf(who: address) : int =
      Map.lookup_default(who, state.recipientConditions, 0)

   public stateful function updateAddress(newAddress': address) =
      require(Map.member(Call.caller, state.recipientConditions), "sender address must be in the list of recipients")
      let weight: int = state.recipientConditions[Call.caller]
      put(state{recipientConditions @ rc = Map.delete(Call.caller, rc)}) // remove old address
      put(state{recipientConditions[newAddress'] = weight}) // add new address
      Chain.event(AddressUpdated(Call.caller, newAddress'))
   
   public stateful function updateRecipientMap(recipients': map(address, int)) =
      onlyOwner()
      require(sumWeights(recipients') == 100, "sum of weights needs to be 100")
      put(state{recipientConditions = recipients'})

   private function sumWeights(recipients': map(address, int)) : int =
      let recipientList: list((address, int)) = Map.to_list(recipients')
      let intList: list(int) = map(pair_second, recipientList)
      let intSum: int = sum(intList, (x) => x)
      intSum
   
   private function map(f : 'a => 'b, l : list('a)) : list('b) =
      switch(l)
         [] => []
         e :: l' => f(e) :: map(f, l')

   private function foldr(f : (('a, 'b) => 'b), z: 'b, l : list('a)) : 'b =
      switch(l)
         [] => z
         e :: l' => f(e, foldr(f, z, l'))

   private function sum(l : list('a), f : 'a => int) : int =
      foldr((x, y) => x + y, 0, map(f, l))

   private function pair_second(tuple) =
      switch(tuple)
         (_, e) => e

   private function onlyOwner() =
      require(Call.caller == state.owner, "caller must be the owner")

   private function require(b: bool, err: string) =
      if(!b) abort(err)